/*
 * Copyright 2017 David Naramski.
 *
 * Licensed under the EUPL, Version 1.1 or - as soon they will be approved by the
 * European Commission - subsequent versions of the EUPL (the "Licence");
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *      http://joinup.ec.europa.eu/software/page/eupl/licence-eupl
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    STATIC = false;
    LOOKAHEAD = 4;
    // FORCE_LA_CHECK = true;
}

PARSER_BEGIN(ScriptParser)
package net.nowina.cadmelia.script.parser;

import net.nowina.cadmelia.construction.Vector;
import net.nowina.cadmelia.script.*;
import net.nowina.cadmelia.script.expression.*;
import java.util.ArrayList;
import java.util.List;

public class ScriptParser {

}
PARSER_END(ScriptParser)

SKIP: {
   < " " | "\t" | "\r" | "\n" | "\r\n" >
 | < "//" (~["\r", "\n"])* >
 | < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
   < "*/" > : DEFAULT
 | < ~[] >
}

TOKEN: {
   < MODULE : "module" >
 | < FUNCTION : "function" >
 | < BOOLEAN : "true" | "false" >
 | < FOR : "for" >
 | < IF : "if" >
 | < THEN : "then" >
 | < ELSE : "else" >
 | < BOOLEAN_EQUAL : "==" >
 | < BOOLEAN_NOT_EQUAL : "!=" >
 | < BOOLEAN_NOT : "!" >
 | < USE : "use" >
 | < GT : ">" >
 | < LT : "<" >
 | < GTE : ">=" >
 | < LTE : "<=" >
 | < COLON : ":" >
 | < HASH : "#" >
 | < PERCENT : "%" >
 | < LP : "(" >
 | < RP : ")" >
 | < LB : "[" >
 | < RB : "]" >
 | < QUESTION : "?" >
 | < LBRACE : "{" >
 | < RBRACE : "}" >
 | < EQ : "=" >
 | < SEMICOLON : ";" >
 | < COMMA : "," >
 | < SP : " " | "\t" >
 | < PLUS: "+" >
 | < MINUS: "-" >
 | < DIVIDE: "/" >
 | < TIMES: "*" >
 | < QUOTE: "\"" > : STRING_STATE
 | < NUMBER : ((["0"-"9"])+)? ("." (["0"-"9"])+)?("e"("+"|"-")?(["0"-"9"])+)? >
 | <FILENAME : "<" (["0"-"9","a"-"z","A"-"Z","_","$",".","/","\\"])+ ">" >
 | < NAME : (["0"-"9","a"-"z","A"-"Z","_","$"])+ >
}

<STRING_STATE> MORE:
{
  "\\" : ESC_STATE
}

<STRING_STATE> TOKEN:
{
  < ENDQUOTE : <QUOTE> > : DEFAULT
| < CHAR : ~["\"","\\"]>
}

<ESC_STATE> TOKEN:
{
  <CNTRL_ESC:["\"","\\","/","b","f","n","r","t","u"]> : STRING_STATE
}

Scope scope() :
{
    Instruction instruction;
    Scope scope;
}
{
    <LBRACE>
    { scope = new Scope(); }
    (
        instruction = scopeStatement()
        { scope.addInstruction(instruction); }
    )*
    <RBRACE>
    { return scope; }
}

IfCommand IfCommand() :
{
    IfCommand ifCommand;
    Expression condition;
    Instruction instruction;
}
{
    <IF> <LP> condition = Expression() <RP>
    { ifCommand = new IfCommand(); ifCommand.setCondition(condition); }

    (
        instruction = scope()
        { ifCommand.setThenScope(instruction); }
    |
        instruction = scopeStatement()
        { ifCommand.setThenScope(instruction); }
    )

    ( <ELSE>

        (
            instruction = scope()
            { ifCommand.setElseScope(instruction); }
        |
            instruction = scopeStatement()
            { ifCommand.setElseScope(instruction); }
        )

    )?

    { return ifCommand; }

}


ForCommand For() :
{
    String variable;
    IterableDef iterableDef;
    ForCommand it;
    Instruction instruction;
}
{
    <FOR> <LP> variable = Name() <EQ> iterableDef = iterableDefinition() <RP>
    { it = new ForCommand(variable, iterableDef); }

    (
        instruction = scope()
        { it.setInstruction(instruction); }
    |
        instruction = scopeStatement()
        { it.setInstruction(instruction); }
    )

    { return it; }
}

/**
 * Return value of the <NAME> token
 */
String Name() : {
    Token t;
} {
    t=<NAME> { return t.image; }
}

/**
 * Return value of the <FILENAME> token
 */
String readFilename() : {
    Token t;
} {
    t=<FILENAME> { return t.image; }
}

Double Number() :
{
    Token t;
}
{
    t=<NUMBER> { return new Double(t.image); }
}

Boolean Boolean() :
{
    Token t;
}
{
    t=<BOOLEAN> { return new Boolean(t.image); }
}

Vector LiteralVector() :
{
    Double x,y,z = null;
}
{
    <LB>
        x = Number()
    <COMMA>
        y = Number()

    // Optional could be vector 2D or vector 2D
    (<COMMA>
        z = Number())?

    <RB>
    { return new Vector(x,y,z); }
}

Expression Vector() :
{
    Expression x,y,z = null;
}
{
    <LB>
        x = Expression()
    <COMMA>
        y = Expression()

    // Optional could be vector 2D or vector 2D
    (<COMMA>
        z = Expression())?

    <RB>
    { return ExpressionBuilder.element(x,y,z); }
}

IterableDef iterableDefinition() :
{
    IterableDef def;
}
{
    def = listDefinition()
    { return def; }
    |
    def = rangeDefinition()
    { return def; }
    |
    def = listFor()
    { return def; }
}

ListIterableDef listDefinition() :
{
    ListIterableDef l = null;
    Expression expr = null;
}
{
    <LB>
    expr = Expression()
    { l = new ListIterableDef(); l.add(expr); }
    (
        <COMMA>
        expr = Expression()
        { l.add(expr); }
    )*
    <RB>
    { return l; }
}

RangeIterableDef rangeDefinition() :
{
    Expression start;
    Expression end;
    Expression increment = null;
}
{
    <LB>
    start = Expression()
    <COLON>
    (
        increment = Expression()
        <COLON>
    )?
    end = Expression()
    <RB>
    { return new RangeIterableDef(start, end, increment); }
}

InlineForExpression listFor() :
{
    String var;
    IterableDef range = null;
    Expression expr = null;
}
{
    // [for (i=[0:num-1], a=i*360/num) [ r*cos(a), r*sin(a) ]]
    <LB> <FOR> <LP>
        var = Name()
    <EQ>
        range = iterableDefinition()
    (<COMMA> Name() <EQ> Expression())*
    <RP>
        expr = Expression()
    <RB>
    { return new InlineForExpression(var, range, expr); }
}

List VectorList() :
{
    List l = null;
    Expression v = null;
}
{
    <LB>
        v = Vector()
        { l = new ArrayList(); l.add(v); }
    (
    <COMMA>
        v = Vector()
        { l.add(v); }
        )*
    <RB>
    { return l; }
}

Argument Argument() :
{
    String name = null;
    Expression value;
}
{
    (LOOKAHEAD(3) name = Name() <EQ> )?
    (value = Expression())
    {
        return new Argument(name, value);
    }
}

Parameter Parameter() :
{
    String name = null;
    Object value = null;
}
{
    name = Name() (
        <EQ>
        (value = Number() | value = LiteralVector() | value = Boolean() | value = String())
    )?
    {
        return new Parameter(name, value);
    }
}

Command control() :
{
    Command command;
}
{
    command = For() (<SEMICOLON>)?
    { return command; }

    |

    command = IfCommand() (<SEMICOLON>)?
    { return command; }
}

Command Command() :
{
    String name;
    Command command;
    Argument arg;
}
{

    (<HASH> | <PERCENT>)?
    name = Name()
    { command = new Command(name); }
    <LP>
        ((arg = Argument()
        { command.addArg(arg); } )?
        (<COMMA> arg = Argument()
        { command.addArg(arg); } )* )
    <RP>
    {
        return command;
    }
}

Command Chain() :
{
    Command chain = null;
    Command command = null;
    Command previous = null;
    Command internal = null;
    Scope scope = null;
}
{
    ( command = Command()
        { if(chain==null) chain = command;
          if(previous!=null) previous.addOperation(command);
          previous = command;
        }
    )+

    (
        ( command = control()
            { if(chain==null) chain = command;
              if(previous!=null) previous.addOperation(command);
              previous = command;
            }
        )
        |
        (<LBRACE>

            (
                internal = Chain()
                { command.addOperation(internal); }

                |

                internal = control()
                { command.addOperation(internal); }
            )*

        <RBRACE>)
    )?

    (<SEMICOLON>)?
    {return chain;}

}

Module Module() :
{
    String name;
    Module m;
    Instruction instruction;
    Parameter param;
}
{
    <MODULE> name = Name()
    { m = new Module(name); }
    <LP>
         ((param = Parameter()
            { m.addParam(param); } )?
         (<COMMA> param = Parameter()
            { m.addParam(param); } )* )
    <RP>
    (
        (
            instruction = scopeStatement()
            { m.addInstruction(instruction); }
            (<SEMICOLON>)?
        )
    |
        (
        <LBRACE>
            ( instruction = Statement()
            { m.addInstruction(instruction); }
            )+
        <RBRACE>
        )
    )
    { return m; }
}


Function FunctionDef() :
{
    String name;
    Function fun;
    Expression expression;
    Parameter param;
}
{
    <FUNCTION> name = Name()
    { fun = new Function(name); }
    <LP>
         ((param = Parameter()
            { fun.addParam(param); } )?
         (<COMMA> param = Parameter()
            { fun.addParam(param); } )* )
    <RP>
    <EQ>
        expression = Expression()
        { fun.setExpression(expression); }
    <SEMICOLON>
    { return fun; }
}

/* ScopeStatement parse statement that can be inside a scope {} */
Instruction scopeStatement() :
{
    Define def;
    Command op;
    Function fun;
}
{
    def = Assignment()
    { return def; }

    |

    fun = FunctionDef()
    { return fun; }

    |

    op = Chain()
    { return op; }

    |

    op = control()
    { return op; }

}

Instruction Statement() :
{
    Instruction instruction;
    Module module;
}
{
    instruction = scopeStatement()
    { return instruction; }

    |

    instruction = useFile()
    { return instruction; }

    |

    module = Module()
    { return module; }
}

Instruction useFile() :
{
    Instruction instr;
    String filename;
}
{
    <USE> filename = readFilename()
    {
        return new Instruction(InstructionType.USE);
    }
}

Script Script() :
{
    Script script;
    Instruction instruction;
}
{
    { script = new Script(); }
    (
        instruction = Statement()
        { script.add(instruction); }
    )* <EOF>
    { return script; }
}

Command Function() :
{
    Command command;
    String f;
    Expression ex;
}
{
    f = Name()
    { command = new Command(f); }
    <LP>
        (ex = Expression()
        { command.addArg(ex); }
        )?
        (<COMMA> ex = Expression()
        { command.addArg(ex); }
        )*
    <RP>
    { return command; }
}

Expression Element() :
{
    Double value;
    String name;
    Boolean bool;
    String text;
    List list;
    Command function;
    Expression expression;
}
{
    value = Number()
    { return ExpressionBuilder.element(value); }
    |
    expression = listFor()
    { return expression; }
    |
    expression = vectorElement()
    { return expression; }
    |
    function = Function()
    { return ExpressionBuilder.elementFunction(function); }
    |
    name = Name()
    { return ExpressionBuilder.element(name); }
    |
    list = VectorList()
    { return ExpressionBuilder.element(list); }
    |
    expression = Vector()
    { return expression; }
    |
    bool = Boolean()
    { return ExpressionBuilder.element(bool); }
    |
    text = String()
    { return ExpressionBuilder.elementText(text); }
    |
    <LP> expression = Expression() <RP>
    { return expression; }
}

Expression vectorElement() :
{
    String variableName;
    Expression index;
}
{
    variableName = Name()
    <LB>
        index = Expression()
    <RB>
    {
        return ExpressionBuilder.vectorElement(variableName, index);
    }
}

Expression Unary() :
{
    Expression expression;
}
{
    <MINUS> expression = Element() { return expression.neg(); }
    | <PLUS> expression = Element() { return expression; }
    | expression = Element() { return expression; }
}

Expression Term() :
{
    Expression expression;
    Expression term;
}
{
    expression = Unary()
    (
        <TIMES> term = Unary()
        { expression = expression.times(term); }
        | <DIVIDE> term = Unary()
        { expression = expression.divide(term);}
    )*
    { return expression; }
}

Expression Factor() :
{
    Expression expression;
    Expression exp2;
}
{
    expression = Term()
    (
        <PLUS> exp2 = Term()
        { expression = expression.plus(exp2); }
        |
        <MINUS> exp2 = Term()
        { expression = expression.minus(exp2); }
    )*
    { return expression; }
}

Expression BooleanOrExpression() :
{
    Expression exp;
    Expression exp2;
}
{
    exp = Factor()
    (
        <BOOLEAN_EQUAL> exp2 = Factor()
        { exp = exp.booleanEquals(exp2); }
        |
        <BOOLEAN_NOT_EQUAL> exp2 = Factor()
        { exp = exp.booleanNotEquals(exp2); }
        |
        <GTE> exp2 = Factor()
        { exp = exp.greaterOrEqualThan(exp2); }
        |
        <LTE> exp2 = Factor()
        { exp = exp.lowerOrEqualThan(exp2); }
        |
        <LT> exp2 = Factor()
        { exp = exp.lowerThan(exp2); }
        |
        <GT> exp2 = Factor()
        { exp = exp.greaterThan(exp2); }
    )?
    { return exp; }
}

Expression Expression() :
{
    Expression exp;
    Expression thenExpr = null;
    Expression elseExpr = null;
}
{
    exp = BooleanOrExpression()
    (
        <QUESTION>
        thenExpr = Term()
        <COLON>
        elseExpr = Term()
        { return ExpressionBuilder.inlineIf(exp, thenExpr, elseExpr); }
    )?
    { return exp; }
}

Define Assignment() :
{
    Token name = null;
    Expression expression = null;
}
{
    name = <NAME>
    <EQ>
    expression = Expression()
    <SEMICOLON>
    { return new Define(name.image, expression); }
}

/**
 * Match a quoted string.
 */
String String() :
{
  StringBuilder builder = new StringBuilder();
}
{
  <QUOTE> ( ConsumeChar(builder) )* <ENDQUOTE>
  {
    return builder.toString();
  }
}

/**
 * Match char inside quoted string.
 */
void ConsumeChar(StringBuilder builder):
{
  Token t;
}
{
  ( t = <CHAR> | t = <CNTRL_ESC> )
  {
    if (t.image.length() < 2)
    {
      // CHAR
      builder.append(t.image.charAt(0));
    }
    else if (t.image.length() < 6)
    {
      // ESC
      char c = t.image.charAt(1);
      switch (c)
      {
        case 'b': builder.append((char) 8); break;
        case 'f': builder.append((char) 12); break;
        case 'n': builder.append((char) 10); break;
        case 'r': builder.append((char) 13); break;
        case 't': builder.append((char) 9); break;
        case 'u':
            builder.append('*'); break;
        default: builder.append(c);
      }
    }
  }
}
